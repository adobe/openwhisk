akka {

  allocator {
    webport=${WEB_PORT}
    enable-predictions=${ALLOCATOR_ENABLE_PREDICTIONS}
    predictions-host=${ALLOCATOR_PREDICTIONS_HOST}
    predictions-port=${ALLOCATOR_PREDICTIONS_PORT}
  }

  isolates.backends {
    mock-backends = ${ALLOCATOR_MOCK_BACKENDS}
    mock-backends-number = ${ALLOCATOR_MOCK_BACKENDS_NUMBER}
    # API server, cert and token information. Currently these are present on K8s versions: 1.6, 1.7, 1.8, and perhaps more
    api-ca-path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    api-token-path = "/var/run/secrets/kubernetes.io/serviceaccount/token"

    api-service-host-env-name = "KUBERNETES_SERVICE_HOST"
    api-service-port-env-name = "KUBERNETES_SERVICE_PORT"

    # Namespace discovery path
    #
    # If this path doesn't exist, the namespace will default to "default".
    pod-namespace-path = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"

    # Namespace to query for pods.
    #
    # Set this value to a specific string to override discovering the namespace using pod-namespace-path.
    pod-namespace = ${MY_POD_NAMESPACE}
    pod-domain = "cluster.local"
    pod-label-selector = "app=%s"
    nodejs-pod-app-label = "runtime-isolate"
    use-raw-ip = false
    nodejs-service-name = "runtime-isolate"
    pod-port-name = "worker0"
  }

  log-dead-letters = 10
  log-dead-letters-during-shutdown = on
  loglevel = INFO
  actor {
    allow-java-serialization = off
    provider = "cluster"
    serializers {
      jackson-json = "akka.serialization.jackson.JacksonJsonSerializer"
      kryo = "com.twitter.chill.akka.AkkaSerializer"
    }

    serialization-bindings {
      "org.apache.openwhisk.core.loadBalancer.allocator.Allocation" = kryo
      "org.apache.openwhisk.core.loadBalancer.allocator.TenantSlot" = kryo
      "org.apache.openwhisk.core.loadBalancer.allocator.ResolvedTarget" = kryo
    }
  }
  remote {
    artery {
      enabled = on
      transport = tcp
      canonical {
        port = ${AKKA_PORT}
        hostname = ${MY_POD_IP}
      }
      bind {
        port = ${AKKA_PORT}
        hostname = ${MY_POD_IP}
        bind-timeout = 3s
      }

      log-sent-messages = on
      log-received-messages = on
    }
  }
  discovery {
    method = kubernetes-api
    kubernetes-api {
      pod-label-selector = "app=%s"
      pod-namespace = ${MY_POD_NAMESPACE}
    }
  }

  management {
    health-checks {
      readiness-checks {
        example-ready = "org.apache.openwhisk.core.loadBalancer.allocator.BasicHealthCheck"
      }
    }
    health-check: {
      ready-states: ["Up", "WeaklyUp"]
      readiness-path: "ready"
      liveness-path: "alive"
    }
    http {
      hostname = ${MY_POD_IP}
      bind-hostname = "0.0.0.0"
      port = ${MANAGEMENT_PORT}
      bind-port = ${MANAGEMENT_PORT}
    }
    cluster {
      bootstrap {
        contact-point-discovery {
          discovery-method = kubernetes-api
          required-contact-point-nr = 0
          port-name = management
        }
        new-cluster-enabled = on
      }
      http {
        hostname = ${MY_POD_IP}
        port = ${MANAGEMENT_PORT}
      }
    }
  }
  cluster {
    seed-nodes = []
  }

}
