akka {

  allocator {
    webport=${WEB_PORT}
    enable-predictions=${ALLOCATOR_ENABLE_PREDICTIONS}
    predictions-host=${ALLOCATOR_PREDICTIONS_HOST}
    predictions-port=${ALLOCATOR_PREDICTIONS_PORT}
  }

  isolates.backends {
    mock-backends = ${ALLOCATOR_MOCK_BACKENDS}
    mock-backends-number = ${ALLOCATOR_MOCK_BACKENDS_NUMBER}
    # API server, cert and token information. Currently these are present on K8s versions: 1.6, 1.7, 1.8, and perhaps more
    api-ca-path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    api-token-path = "/var/run/secrets/kubernetes.io/serviceaccount/token"

    api-service-host-env-name = "KUBERNETES_SERVICE_HOST"
    api-service-port-env-name = "KUBERNETES_SERVICE_PORT"

    # Namespace discovery path
    #
    # If this path doesn't exist, the namespace will default to "default".
    pod-namespace-path = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"

    # Namespace to query for pods.
    #
    # Set this value to a specific string to override discovering the namespace using pod-namespace-path.
    pod-namespace = ${MY_POD_NAMESPACE}
    pod-domain = "cluster.local"
    pod-label-selector = "app=%s"
    nodejs-pod-app-label = "runtime-isolate"
    use-raw-ip = false
    nodejs-service-name = "runtime-isolate"
    pod-port-name = "worker0"
  }

  log-dead-letters = 10
  log-dead-letters-during-shutdown = on
  loglevel = DEBUG
  actor {
    allow-java-serialization = off
    provider = "cluster"
    serializers {
      jackson-json = "akka.serialization.jackson.JacksonJsonSerializer"
      kryo = "com.twitter.chill.akka.AkkaSerializer"
    }

    serialization-bindings {
      "org.apache.openwhisk.core.loadBalancer.allocator.Allocation" = kryo
      "org.apache.openwhisk.core.loadBalancer.allocator.TenantSlot" = kryo
      "org.apache.openwhisk.core.loadBalancer.allocator.ResolvedTarget" = kryo
    }
  }
}
